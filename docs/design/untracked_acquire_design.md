# AdaptiveArrayPools: Untracked Acquire Handling Design

## 1. Background

### 1.1 Current System
Julia array pool library. The `@with_pool` macro manages temporary array allocation through checkpoint/rewind.

```julia
@with_pool p begin
    v = acquire!(p, Float64, 100)  # Acquire array from pool
    # ... use ...
end  # Automatically returned
```

### 1.2 Optimization: Typed Checkpoint/Rewind
The macro extracts types from acquire! calls at compile time, checkpointing/rewinding only those types (77% performance improvement).

```julia
# Code generated by macro
checkpoint!(pool, Float64)  # Only checkpoint Float64 stack
try
    v = acquire!(pool, Float64, 100)
finally
    rewind!(pool, Float64)  # Only rewind Float64 stack
end
```

### 1.3 Current Data Structures
```julia
mutable struct TypedPool{T}
    vectors::Vector{Vector{T}}  # Reusable arrays
    n_active::Int               # Number of currently active arrays
    _checkpoint_n_active::Vector{Int}  # Checkpointed n_active values
    _checkpoint_depths::Vector{Int}    # Depth at which each checkpoint was saved
end

mutable struct AdaptiveArrayPool
    float64::TypedPool{Float64}
    float32::TypedPool{Float32}
    int64::TypedPool{Int64}
    int32::TypedPool{Int32}
    complexf64::TypedPool{ComplexF64}
    complexf32::TypedPool{ComplexF32}
    bool::TypedPool{Bool}
    others::IdDict{DataType, Any}
    _current_depth::Int
    _untracked_flags::Vector{Bool}
end
```

---

## 2. Problem: Untracked Acquire

### 2.1 Scenario
```julia
function inner_helper(pool)
    acquire!(pool, Float32, 50)  # Macro can't see this!
end

@with_pool p begin
    v = acquire!(p, Float64, 100)  # Macro extracts: Float64
    inner_helper(p)                 # Float32 acquire is "untracked"
end
```

**Problem:** Macro only knows about Float64, generating `checkpoint!(pool, Float64)`, `rewind!(pool, Float64)`.
Float32's n_active is not restored → memory leak or corruption.

### 2.2 Nested Case
```julia
@with_pool p begin                    # L1: checkpoint Float64
    acquire!(p, Float64, 10)

    @with_pool p begin                # L2: checkpoint Int64
        acquire!(p, Int64, 5)
        inner_untracked(p)            # Float32 acquire (untracked)
    end                               # L2 rewind

end                                   # L1 rewind
```

---

## 3. Proposed Solution

### 3.1 Core Idea: Shared Implementation Function + Marking Wrapper

**Previous Problem:** Runtime detection in acquire! → overhead on every call

**New Approach:**
- `_acquire_impl!` → actual implementation (existing acquire! logic as-is)
- `acquire!` → marking + `_acquire_impl!` call (1-line wrapper)
- Macro transforms `acquire!` calls to `_acquire_impl!`

```julia
# User code
@with_pool p begin
    v = acquire!(p, Float64, 100)
end

# After macro transformation
checkpoint!(p, Float64)
try
    v = _acquire_impl!(p, Float64, 100)  # ← Transformed! (no marking)
finally
    # ...
end
```

### 3.2 Benefits
1. **Zero overhead:** Inside @with_pool, impl is called directly
2. **Automatic detection:** acquire! outside @with_pool passes through marking wrapper → untracked
3. **No code duplication:** Implementation logic in `_acquire_impl!` only once

### 3.3 Data Structure Changes

```julia
mutable struct TypedPool{T}
    # ... existing fields ...
    n_active::Int
    _checkpoint_n_active::Vector{Int}
    _checkpoint_depths::Vector{Int}   # NEW: Tracks which depth each checkpoint was saved at
end

mutable struct AdaptiveArrayPool
    # ... existing TypedPools ...

    # NEW: Depth tracking (pool level)
    _current_depth::Int               # Current checkpoint depth
    _untracked_flags::Vector{Bool}    # Whether untracked occurred per depth (typed vs full rewind decision)
end
```

**Key Changes:**
- `_checkpoint_depths` added to `TypedPool` → tracks which depth each checkpoint occurred at
- `_untracked_flags` maintained → for typed rewind vs full rewind decision
- `_full_rewind_with_types!` removed → `_checkpoint_depths` makes regular `rewind!(pool)` sufficient

---

## 4. Implementation Details

### 4.1 Function Structure

```julia
# Implementation function (existing acquire! logic moved as-is)
@inline function _acquire_impl!(pool::AdaptiveArrayPool, ::Type{T}, n::Int) where T
    tp = get_typed_pool!(pool, T)
    return get_view!(tp, n)
end

@inline function _acquire_impl!(pool::AdaptiveArrayPool, ::Type{T}, dims::Vararg{Int,N}) where {T,N}
    tp = get_typed_pool!(pool, T)
    return get_nd_view!(tp, dims)
end

# User-facing: marking wrapper (1 line)
@inline function acquire!(pool::AdaptiveArrayPool, ::Type{T}, n::Int) where T
    _mark_untracked!(pool)
    _acquire_impl!(pool, T, n)
end

@inline function acquire!(pool::AdaptiveArrayPool, ::Type{T}, dims::Vararg{Int,N}) where {T,N}
    _mark_untracked!(pool)
    _acquire_impl!(pool, T, dims...)
end

# Untracked marking (still needed - for typed rewind vs full rewind decision)
# Note: 1-based sentinel pattern guarantees _current_depth >= 1, so no check needed
@inline function _mark_untracked!(pool::AbstractArrayPool)
    # Always mark (_current_depth >= 1 guaranteed by sentinel)
    @inbounds pool._untracked_flags[pool._current_depth] = true
end
```

**Macro transformation:** `acquire!(p, T, n)` → `_acquire_impl!(p, T, n)` (only function name substitution)

**Note:** `_mark_untracked!` is maintained - for triggering full rewind when untracked occurs

### 4.2 unsafe_acquire! and Aliases

```julia
# Implementation functions
@inline function _unsafe_acquire_impl!(pool::AdaptiveArrayPool, ::Type{T}, n::Int) where T
    tp = get_typed_pool!(pool, T)
    return get_nd_array!(tp, (n,))
end

@inline function _unsafe_acquire_impl!(pool::AdaptiveArrayPool, ::Type{T}, dims::Vararg{Int,N}) where {T,N}
    tp = get_typed_pool!(pool, T)
    return get_nd_array!(tp, dims)
end

# User-facing: marking wrapper
@inline function unsafe_acquire!(pool::AdaptiveArrayPool, ::Type{T}, n::Int) where T
    _mark_untracked!(pool)
    _unsafe_acquire_impl!(pool, T, n)
end

@inline function unsafe_acquire!(pool::AdaptiveArrayPool, ::Type{T}, dims::Vararg{Int,N}) where {T,N}
    _mark_untracked!(pool)
    _unsafe_acquire_impl!(pool, T, dims...)
end

# Aliases (user API)
const acquire_view! = acquire!
const acquire_array! = unsafe_acquire!

# Aliases (internal impl)
const _acquire_view_impl! = _acquire_impl!
const _acquire_array_impl! = _unsafe_acquire_impl!
```

### 4.3 Macro Transformation

```julia
# Macro transforms acquire! calls in AST to _*_impl!
function _transform_acquire_calls(expr, pool_name)
    if expr isa Expr
        if expr.head == :call && length(expr.args) >= 2
            fn = expr.args[1]
            pool_arg = expr.args[2]

            # Only transform when matching target pool
            if pool_arg == pool_name
                if fn == :acquire! || fn == :acquire_view!
                    expr.args[1] = :_acquire_impl!
                elseif fn == :unsafe_acquire! || fn == :acquire_array!
                    expr.args[1] = :_unsafe_acquire_impl!
                end
            end
        end
        # Recursively transform
        for i in eachindex(expr.args)
            expr.args[i] = _transform_acquire_calls(expr.args[i], pool_name)
        end
    end
    return expr
end
```

**Transformation Rules:**
| Original | Transformed |
|----------|-------------|
| `acquire!(p, ...)` | `_acquire_impl!(p, ...)` |
| `acquire_view!(p, ...)` | `_acquire_impl!(p, ...)` |
| `unsafe_acquire!(p, ...)` | `_unsafe_acquire_impl!(p, ...)` |
| `acquire_array!(p, ...)` | `_unsafe_acquire_impl!(p, ...)`|

### 4.4 Checkpoint/Rewind

```julia
# Typed checkpoint
function checkpoint!(pool::AdaptiveArrayPool, types::Type...)
    pool._current_depth += 1
    push!(pool._untracked_flags, false)
    depth = pool._current_depth
    for T in types
        tp = get_typed_pool!(pool, T)
        push!(tp._checkpoint_n_active, tp.n_active)
        push!(tp._checkpoint_depths, depth)        # NEW: record depth
    end
end

# Typed rewind (fast path - when no untracked)
function rewind!(pool::AdaptiveArrayPool, types::Type...)
    for T in types
        tp = get_typed_pool!(pool, T)
        pop!(tp._checkpoint_depths)                 # NEW: remove depth
        tp.n_active = pop!(tp._checkpoint_n_active)
    end
    pop!(pool._untracked_flags)
    pool._current_depth -= 1
end

# Full rewind (untracked fallback - simplified with _checkpoint_depths!)
# Note: Uses 1-based sentinel pattern. At global scope (depth=1), delegates to reset!()
function rewind!(pool::AdaptiveArrayPool)
    cur_depth = pool._current_depth

    # Safety guard: at global scope (depth=1), no checkpoint to rewind to
    # Delegate to reset! which safely clears all n_active counters
    if cur_depth == 1
        reset!(pool)
        return nothing
    end

    # Fixed slots - zero allocation via @generated iteration
    foreach_fixed_slot(pool) do tp
        _rewind_typed_pool!(tp, cur_depth)
    end

    # Process fallback types
    for tp in values(pool.others)
        _rewind_typed_pool!(tp, cur_depth)
    end

    pop!(pool._untracked_flags)
    pool._current_depth -= 1
    return nothing
end

# Internal helper for rewind with orphan cleanup
# Uses 1-based sentinel pattern: no isempty checks needed
@inline function _rewind_typed_pool!(tp::AbstractTypedPool, current_depth::Int)
    # 1. Orphaned Checkpoints Cleanup
    while @inbounds tp._checkpoint_depths[end] > current_depth
        pop!(tp._checkpoint_depths)
        pop!(tp._checkpoint_n_active)
    end

    # 2. Normal Rewind Logic (Sentinel Pattern)
    if @inbounds tp._checkpoint_depths[end] == current_depth
        pop!(tp._checkpoint_depths)
        tp.n_active = pop!(tp._checkpoint_n_active)
    else
        # No checkpoint at current depth - restore from parent
        tp.n_active = @inbounds tp._checkpoint_n_active[end]
    end
    nothing
end
```

**Key Improvement:** `_checkpoint_depths[end] == depth` comparison enables accurate pop/restore decision → `_full_rewind_with_types!` not needed!

### 4.5 Zero-Allocation Iteration (Current Implementation)

> **Note**: The design originally proposed `all_type_stacks()` generator, but was replaced with
> `foreach_fixed_slot()` @generated function for zero allocation via compile-time unrolling.

```julia
# Current implementation uses @generated for zero allocation
const FIXED_SLOT_FIELDS = (:float64, :float32, :int64, :int32, :complexf64, :complexf32, :bool)

@generated function foreach_fixed_slot(f::F, pool::AdaptiveArrayPool) where {F}
    exprs = [:(f(getfield(pool, $(QuoteNode(field))))) for field in FIXED_SLOT_FIELDS]
    quote
        Base.@_inline_meta
        $(exprs...)
        nothing
    end
end
```

**Benefits over generator approach**:
- Zero allocation via compile-time unrolling
- Full inlining for hot paths
- No runtime iteration overhead

### 4.6 Macro Generated Code

```julia
@with_pool p begin
    v = acquire!(p, Float64, 100)
    inner_function(p)  # untracked acquire possible here
end

# Generated code:
local p = get_task_local_pool()
checkpoint!(p, Float64)
try
    local _result = begin
        v = _acquire_impl!(p, Float64, 100)  # ← Transformed! (no marking)
        inner_function(p)  # acquire! inside not transformed → passes through marking wrapper → untracked
    end
    _result
finally
    if p._untracked_flags[p._current_depth]
        rewind!(p)                  # Full rewind (handled accurately with _checkpoint_depths)
    else
        rewind!(p, Float64)         # Typed rewind (fast)
    end
end
```

**Change:** `_full_rewind_with_types!(p, Float64)` → `rewind!(p)` (simplified!)

---

## 5. Behavior Verification

### 5.1 Simple Case (no untracked)

```julia
@with_pool p begin
    v = acquire!(p, Float64, 100)
end
```

**Flow:**
1. `checkpoint!(p, Float64)` → _current_depth=1, _untracked_flags=[false]
2. `_acquire_impl!(p, Float64, 100)` → no marking (macro transformed)
3. `_untracked_flags[1] == false` → `rewind!(p, Float64)` (fast path)

### 5.2 Untracked Case

```julia
function helper(p)
    acquire!(p, Float32, 50)  # Defined outside @with_pool → not transformed!
end

@with_pool p begin
    v = acquire!(p, Float64, 100)
    helper(p)
end
```

**Flow:**
1. `checkpoint!(p, Float64)` → _current_depth=1, _untracked_flags=[false], Float64._checkpoint_depths=[1]
2. `_acquire_impl!(p, Float64, 100)` → no marking (macro transformed)
3. `acquire!(p, Float32, 50)` → marking wrapper → `_mark_untracked!` → _untracked_flags=[true]
4. `_untracked_flags[1] == true` → `rewind!(p)` (full rewind)
   - Float64: _checkpoint_depths[end]=1 == depth=1 → pop
   - Float32: _checkpoint_depths=[] → if n_active=0 do nothing, if >0 restore

### 5.3 Nested Case

```
L1: @with_pool (Float64)
  L2: @with_pool (Int64) + untracked Float32
    L3: @with_pool (Bool)
```

| Timing | depth | Float64 saved/depths | Int64 saved/depths | Float32 saved/depths | Bool saved/depths |
|--------|-------|---------------------|-------------------|---------------------|------------------|
| Initial | 0 | []/[] | []/[] | []/[] | []/[] |
| L1 checkpoint(F64) | 1 | [0]/[1] | []/[] | []/[] | []/[] |
| L2 checkpoint(I64) | 2 | [0]/[1] | [0]/[2] | []/[] | []/[] |
| Float32 untracked | 2 | [0]/[1] | [0]/[2] | []/[] (n=1) | []/[] |
| L3 checkpoint(Bool) | 3 | [0]/[1] | [0]/[2] | []/[] | [0]/[3] |
| L3 rewind(Bool) | 2 | [0]/[1] | [0]/[2] | []/[] | []/[] |
| L2 rewind() full | 1 | [0]/[1] | []/[] | []/[] (n=0) | []/[] |
| L1 rewind(F64) | 0 | []/[] | []/[] | []/[] | []/[] |

**L2 Full Rewind Detail (depth=2):**
- Float64: depths[end]=1 ≠ 2 → no pop, restore only ✓
- Int64: depths[end]=2 == 2 → **pop!** ✓ (now works correctly!)
- Float32: depths=[] → n_active to 0 (untracked cleanup) ✓
- Bool: depths=[] → n_active=0, do nothing ✓

**Key:** Thanks to `_checkpoint_depths`, we can accurately know Int64 was checkpointed at depth=2!

---

## 6. API Summary

### 6.1 User API (unchanged)
```julia
acquire!(pool, T, dims...)       # Acquire array (returns view)
unsafe_acquire!(pool, T, dims...)  # Acquire array (returns Array)
acquire_view!(pool, T, dims...)    # alias for acquire!
acquire_array!(pool, T, dims...)   # alias for unsafe_acquire!
```

### 6.2 Internal API (newly added)
```julia
# Implementation functions (macro transforms to direct call)
_acquire_impl!(pool, T, dims...)
_unsafe_acquire_impl!(pool, T, dims...)

# Aliases (const)
_acquire_view_impl! = _acquire_impl!
_acquire_array_impl! = _unsafe_acquire_impl!

# Untracked marking
_mark_untracked!(pool)

# TypedPool iteration
all_type_stacks(pool)  # Generator
foreach_type_stack(f, pool)  # Callback pattern
```

### 6.3 Struct Changes
```julia
mutable struct TypedPool{T}
    # existing fields...
    n_active::Int
    _checkpoint_n_active::Vector{Int}
    _checkpoint_depths::Vector{Int}     # NEW: checkpoint depth tracking
end

mutable struct AdaptiveArrayPool
    # existing fields...
    _current_depth::Int              # NEW
    _untracked_flags::Vector{Bool}   # NEW
end
```

---

## 7. Performance Characteristics

| Path | Condition | Behavior | Overhead |
|------|-----------|----------|----------|
| Fast path | no untracked | typed rewind | Minimal (same as existing) |
| Fallback | untracked exists | full rewind | Iterate all types (accurate handling with _checkpoint_depths) |

### 7.1 acquire! Overhead
```julia
# Implementation function (existing logic as-is)
@inline function _acquire_impl!(pool, T, n)
    tp = get_typed_pool!(pool, T)
    get_view!(tp, n)
end

# User wrapper (marking added)
@inline function acquire!(pool, T, n)
    _mark_untracked!(pool)  # Added: if + array access
    _acquire_impl!(pool, T, n)
end

@inline function _mark_untracked!(pool)
    if pool._current_depth > 0  # branch (usually false)
        @inbounds pool._untracked_flags[pool._current_depth] = true
    end
end
```

**Overhead Analysis:**
- Outside @with_pool: `_current_depth == 0` → branch only (very light)
- Inside @with_pool: macro calls `_acquire_impl!` directly → **zero overhead**

---

## 8. Edge Case: Parent Scope Corruption Prevention

### 8.1 Problem Scenario
```julia
# acquire outside @with_pool
v_parent = acquire!(p, Int64, 10)  # Int64 n_active = 1

@with_pool p begin  # checkpoint(Float64) - Int64 not checkpointed
    v = acquire!(p, Float64, 100)

    # Untracked Int64 acquire!
    v_child = acquire!(p, Int64, 5)  # Int64 n_active = 2
end
# Full rewind occurs
# Int64: _checkpoint_n_active=[], n_active=2
# If reset n_active=0, v_parent would be destroyed!
```

### 8.2 Solution: Clear Error
```julia
elseif tp.n_active > 0
    # _checkpoint_n_active empty but n_active > 0
    # = attempting rewind without checkpoint
    T = eltype(tp)
    error("""
        [AdaptiveArrayPools] Cannot rewind type $T: no checkpoint exists.
        Found $(tp.n_active) active array(s) that were never checkpointed.

        Fix: Wrap the scope where $T was first acquired in @with_pool.
        """)
end
```

### 8.3 Error Conditions Summary
| _checkpoint_n_active | n_active | Situation | Action |
|----------------------|----------|-----------|--------|
| len == depth | any | Checkpointed at current depth | pop |
| len > 0, < depth | any | Checkpointed at previous depth | restore to [end] |
| empty | 0 | Not used | do nothing |
| empty | > 0 | **Rewind attempted without checkpoint** | **ERROR** |

### 8.4 User Resolution
When error occurs, two choices:
1. **Wrap parent in @with_pool too:**
   ```julia
   @with_pool p begin
       v_parent = acquire!(p, Int64, 10)
       @with_pool p begin
           # inner block
       end
   end
   ```

2. **Avoid untracked acquire in inner block:**
   ```julia
   v_parent = acquire!(p, Int64, 10)
   @with_pool p begin
       # Don't acquire Int64
       # Or use @with_pool in inner helper too
   end
   ```

---

## 9. Feedback Requests

1. **Function separation approach:** Is the `acquire!` wrapper + `_acquire_impl!` implementation separation appropriate?
2. **length vs _current_depth comparison:** Is it correct in all nested cases?
3. **Macro transformation:** Is AST function name substitution safe? (qualified names, macros, etc.)
4. **_untracked_flags Vector{Bool}:** Are there more efficient alternatives?
5. **_full_rewind_with_types!:** Performance of checking types with Set?
6. **Simpler alternative:** Is there a way to simplify the entire design?

---

## 10. Alternative Review

### 10.1 Option: Always Full Checkpoint/Rewind
- Pros: Simple implementation
- Cons: Loses 77% performance improvement

### 10.2 Option: Don't Support Untracked
- Documentation: "Use @with_pool in helper functions too"
- Pros: No implementation changes
- Cons: Silent corruption on user error

### 10.3 Option: Current Proposal (impl function separation)
- Pros: Maintains performance, safe fallback, no code duplication
- Cons: Requires macro transformation
